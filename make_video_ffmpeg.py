#!/usr/bin/env python3
import json
import os
import random
import tempfile
import subprocess
import requests

def download_resource(url, output_path):
    """下载资源文件"""
    print(f"下载资源: {url}")
    response = requests.get(url, stream=True)
    response.raise_for_status()
    with open(output_path, 'wb') as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)
    print(f"下载完成: {output_path}")

def get_audio_duration(audio_path):
    """获取音频文件的实际时长"""
    cmd = [
        'ffprobe', '-v', 'error', '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1', audio_path
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return float(result.stdout.strip())

def create_video_segment(image_path, audio_path, subtitle_text, duration, output_path, index):
    """使用 FFmpeg 创建单个视频片段"""
    print(f"创建视频片段 {index+1}...")
    
    # 获取音频实际时长
    try:
        actual_duration = get_audio_duration(audio_path)
        # 使用实际时长，避免时长不匹配问题
        duration = min(duration, actual_duration)
        print(f"使用音频实际时长: {duration:.2f}秒")
    except Exception as e:
        print(f"获取音频时长失败，使用原始时长: {e}")
    
    # 生成随机动画参数
    zoom_start = 1.0
    zoom_end = random.uniform(1.02, 1.05)  # 减小缩放范围，降低计算量
    pan_x = random.uniform(-10, 10)  # 减小位移范围
    pan_y = random.uniform(-5, 5)
    
    # 创建字幕文件
    subtitle_file = os.path.join(os.path.dirname(output_path), f"subtitle_{index}.ass")
    create_subtitle_file(subtitle_text, subtitle_file, duration)
    
    # 构建 FFmpeg 命令，使用 ASS 字幕文件
    # 9:16 竖屏比例：1080x1920
    
    cmd = [
        'ffmpeg', '-y',
        # 输入图片
        '-loop', '1', '-i', image_path,
        # 输入音频
        '-i', audio_path,
        # 缩放图片并添加 ASS 字幕
        '-vf', f"scale=1080:1920,ass={subtitle_file}",
        # 编码设置
        '-c:v', 'libx264', '-preset', 'fast', '-crf', '25',  # 使用 faster preset
        '-c:a', 'aac', '-b:a', '128k',
        # 时长设置
        '-t', str(duration),
        # 输出文件
        output_path
    ]
    
    # 执行命令
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"FFmpeg 错误: {result.stderr}")
            raise Exception(f"FFmpeg 执行失败: {result.stderr}")
        print(f"视频片段 {index+1} 创建完成")
    except Exception as e:
        print(f"创建视频片段失败: {e}")
        raise

def add_line_breaks(text, max_chars=13):
    """
    主要针对中文的自动换行，也兼容英文
    max_chars: 每行大约多少个中文字符
    1080p 竖屏, margins=60*2=120, usable=960. font=70. 960/70 ~= 13.7. 
    Suggested max_chars=13.
    """
    lines = []
    current_line = ""
    current_length = 0
    
    # 遍历每个字符
    for char in text:
        # 中文字符算1，其他(如英文、数字、标点)算0.5
        char_len = 1 if ord(char) > 127 else 0.5
        
        # 如果加上当前字符会超出限制（且当前行不为空），则换行
        if current_length + char_len > max_chars and current_line:
            lines.append(current_line)
            current_line = char
            current_length = char_len
        else:
            current_line += char
            current_length += char_len
            
    if current_line:
        lines.append(current_line)
        
    # ASS格式换行符是 \N
    return '\\N'.join(lines)

def create_subtitle_file(text, output_path, duration):
    """创建 ASS 字幕文件"""
    
    # 添加换行符
    wrapped_text = add_line_breaks(text)
    
    # 为竖屏 1080x1920 调整 ASS 配置
    ass_content = f"""[Script Info]
; Script generated by make_video_ffmpeg.py
Title: Subtitle
ScriptType: v4.00+
PlayResX: 1080
PlayResY: 1920
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial Unicode MS,70,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,2,2,60,60,350,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:{int(duration//60):02d}:{int(duration%60):02d}.00,Default,,60,60,350,,{wrapped_text}
"""
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(ass_content)

def concatenate_videos(segment_files, output_path):
    """合并多个视频片段"""
    print("合并视频片段...")
    
    # 创建文件列表
    list_file = os.path.join(os.path.dirname(output_path), "filelist.txt")
    with open(list_file, 'w') as f:
        for file in segment_files:
            f.write(f"file '{file}'\n")
    
    # 构建 FFmpeg 命令
    cmd = [
        'ffmpeg', '-y',
        '-f', 'concat', '-safe', '0', '-i', list_file,
        '-c', 'copy',
        output_path
    ]
    
    # 执行命令
    subprocess.run(cmd, check=True, capture_output=True, text=True)
    print("视频合并完成")

def main():
    """主函数"""
    # 读取 input.json
    with open('input.json', 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # 验证数据结构
    list_items = data.get('list', [])
    audio_list = data.get('audio_list', [])
    duration_list = data.get('duration_list', [])
    image_list = data.get('image_list', [])
    
    # 检查列表长度是否一致
    if not all(len(lst) == len(list_items) for lst in [audio_list, duration_list, image_list]):
        raise ValueError("所有列表长度必须一致")
    
    # 创建临时目录
    with tempfile.TemporaryDirectory() as temp_dir:
        segment_files = []
        
        # 处理每个片段
        for i, (item, audio_url, duration_ms, image_url) in enumerate(zip(
            list_items, audio_list, duration_list, image_list
        )):
            print(f"处理片段 {i+1}/{len(list_items)}")
            
            # 转换时长为秒
            duration = duration_ms / 1000
            
            # 下载资源
            audio_path = os.path.join(temp_dir, f"audio_{i}.mp3")
            image_path = os.path.join(temp_dir, f"image_{i}.jpg")
            segment_path = os.path.join(temp_dir, f"segment_{i}.mp4")
            
            download_resource(audio_url, audio_path)
            download_resource(image_url, image_path)
            
            # 创建视频片段
            create_video_segment(image_path, audio_path, item['cap'], duration, segment_path, i)
            segment_files.append(segment_path)
        
        # 拼接所有片段
        output_path = "output.mp4"
        concatenate_videos(segment_files, output_path)
        
        print(f"视频生成完成！输出文件: {output_path}")

if __name__ == "__main__":
    main()
